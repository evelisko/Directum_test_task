# Тестовое задание на должность Backend-разработчик сервисов.

**ML:** opencv, pillow, keras, pandas, numpy.

**API:** flask

## Задание

Задание заключается в реализации небольшого, желательно RESTful сервиса по обработке изображений и текста. Без UI. Через HTTP. Все ответы – в формате JSON. Под капотом – минимум Python 3.7, что будет в качестве веб-сервера – на ваше усмотрение.

При оценке будет учитываться структура проекта: выделенные классы, модули, контроллеры и пр. В качестве реализации принимается код на Python, оформленный в виде *.py файлов. Jupyter Notebook/Google Colab использовать можно только для обучения моделей. Ссылки на тетрадки или сами *.ipynb файлы приложите к решению. Обученные модели приложите к решению в виде pickle-файлов.

### 1. Поиск объектов

На изображении страницы необходимо найти местоположение логотипов и подписей. Для их поиска можно использовать как классические (алгоритмические) подходы computervision, так и подходы с использованием нейронных сетей.

На вход подается файл-изображение в формате **\*.tif**. Адрес API и названия параметров для входных данных придумайте самостоятельно.

#### Данные для обучения

Вместе с заданием прилагается набор PNG-файлов с логотипами и подписями, а также XML-файлы, содержащие информацию о местоположении объектов. Эти данные можно использовать для обучения моделей и проверки реализации. XML-файлы содержат информацию в следующем виде:

``` xml
<?xml version="1.0" encoding="UTF-8"?>

<DL_DOCUMENT src="aah97e00-page02_1.tif" NrOfPages="1" docTag="xml">

<DL_PAGE gedi_type="DL_PAGE" src="aah97e00-page02_1.tif" pageID="1" width="2560" height="3296">

<DL_ZONE gedi_type="DLLogo" id="None" col="1074" row="18" width="374" height="219"> </DL_ZONE>

</DL_PAGE>

</DL_DOCUMENT>

</GEDI>
```

Информация о расположении объектов с типом **gedi_type** находится в поле **DL_ZONE****, где **col** и **row** – верхний левый угол обрамляющего прямоугольника, **width** и **height** – ширина и высота обрамляющего прямоугольника.

Изображения для обучения расположены в папке **pages/source**, а XML-файлы с информацией о логотипах в **pages/truth**. Для самопроверки рекомендуется разделить эти данные на два набора – для обучения и для тестирования.

#### Выходные данные

В ответе должна содержаться информацию о местоположении объектов. Местоположение задается с помощью верхнего левого угла, ширины и высоты обрамляющего прямоугольника. Пример:

``` json
{
 "type": "logo",
 "position": 
  {
      "left": 5,
      "top": 10,
      "width": 20,
      "height": 30
     },
 "source": 
  {
      "width": 250,
      "height": 250
  }
}
```

Для логотипов используйте тип **logo**, для подписей – **sign**. Не забудьте вернуть размеры оригинала. Все координаты и размеры указываются в пикселях.

## 2. Классификация

При обработке изображения, нужно определить, является ли она *ведущей (первой)* страницей в документе или нет. Это необходимо, если нам на вход подают несколько документов постранично, и мы хотим разделить их на отдельные документы.

Соответственно, нужно определить, является ли изображение *ведущей* **(первой)** страницей документа. В данном задании можно использовать как методы CV, так и NLP на извлеченном тексте.

На вход подается файл-изображение в формате ***.tif**. Адрес API и названия параметров для входных данных придумайте самостоятельно.

### Данные для обучения

Данные для обучения находятся в **pages/pages**. У каждой страницы в имени файла есть информация о её номере в документе – суффикс **_X**, который обозначает, что это **X-ая** страница документа.

Например, *aah97e00-page02_1.tif* и *aah97e00-page02_2.tif*. Как видно, у них в конце есть суффикс с индексом страницы.

Если же префикс вообще отсутствует, как, например, у *aam09c00.tif*, то это означает, что страница единственная в документе.

### Выходные данные

JSON с описанием является ли страница ведущей (первой) или нет. Структура JSON должна быть такой:

``` json
{
 "source": {
  "width": 200,
  "height": 200,
  "type": "main"
 }
} 

```
В поле *type*. укажите значение **main**, если страница ведущая и **other**, если нет.

## Описание результатов. 

Изучив датасет, обнаружил такую неприятную особенность в разметке данных.
У нас имеется два типа документов. Те что содержат логотипы и, те что содержат подписи. Одно, как бы исключает другое. Но, по факту изображение может содержать как логотип, так и подпись. Просто один из классов не размечен. Для того чтобы избежать проблем с обучением, решил просто создать две модели каждая из которых будет определять координаты объектов своего класса.
Jpyter-ноутбуки с полным описанием всего процесса обучения находятся в папке **experiments**. Файлы обученными моделями находятся в **models** модель. 

### Последовательность действий.

#### 1 . Клонируем репозиторий - 
    
    $ git clone git@github.com:evelisko/Directum_test_task.git

#### 2. Подготовить файлы с обученными молелями: 

2.1. Скачать архив по ссылке :point_right: [Ссылка](https://drive.google.com/file/d/14pSJHegd1rF2lgZ-Mw44a3CpogRJnm6o/view?usp=sharing) 

2.2. Сохранить pickle-файлы из архива в папку /Directum_test_task/models/. 

#### 2. Открыть терминал. Перейти в каталог - 
   
    Directum_test_task/Docker

#### 3. Собрать docker - образ
   
``` bash
$ docker build -t doc_analizer .
```

#### 4. Запустить docker - контейнер

``` bash
 docker run -d -p 8180:8180 -p 8181:8181 -v  /home/sergey/Projects/Directum_test_task/models:/app/app/models doc_analizer
```

#### 5. Проверить что контейнер запущен -

    docker ps -a

#### 6. Проверить работу api - 

Для проверки api запускаем код из ноутбука - Test_doc_analizer.ipynb. :smile:

> **Примечание** - Файл конфигураций для сервера расположен в - `Directum_test_task/Docker/app`.
Так удобней для запуска примера. В последствие, его лучше вынести вынести во внешний каталог за пределы doker - образа. 





